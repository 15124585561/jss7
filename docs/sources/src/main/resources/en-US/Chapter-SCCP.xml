<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [<!ENTITY % BOOK_ENTITIES SYSTEM "SS7_Stack_User_Guide.ent">%BOOK_ENTITIES;]>

<chapter
	id="sccp">

	<title>SCCP</title>
	<para></para>
	<section
		id="sccp_routing">
		<title>Routing Management</title>
		<para>
			Currently
			<literal>Shell</literal>
			does not support commands to manage
			<literal>SCCP</literal>
			routes.
		</para>


	</section>
	<section
		id="sccp_routing_configuration">
		<title>Routing Configuration</title>
		<para>
			Routing rules are persisted within file. By default its
			<filename>sccp-routing.txt</filename>. 
			This file is managed by
			<literal>SCCP</literal>
			stack and
			<literal>SS7 Service</literal>
			, it is not encouraged practice to edit this file by hand. However for complete rerefence, you can find structure of this file below:
		</para>

		<programlisting
			language="XML"
			role="XML"><![CDATA[
sequence;pattern;translation;mtpinfo
]]>
				</programlisting>
		<note>
			<para>
				Fields within
				<literal>pattern</literal>
				,
				<literal>translation</literal>
				and
				<literal>mtp</literal>
				,
				separated by
				<literal>#</literal>
				, empty value is indicated by single
				<literal>space</literal>
				. Each part of routing entry is separated by
				<literal>;</literal>
				.
			</para>
		</note>
		<variablelist>
			<varlistentry>
				<term>sequence</term>
				<listitem>
					<para>is simple sequence number, each entry increases it by 1.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>pattern</term>
				<listitem>
					<para>
						is simply
						<literal>SCCP</literal>
						like regular expresion. Destination address of message is matched against this to check which rule should be triggered.
					</para>

					<table
						frame="all"
						pgwide="1">
						<title>pattern content</title>
						<tgroup
							colsep="1"
							cols="3">
							<colspec
								colnum="1"
								colname="c0" />
							<colspec
								colnum="2"
								colname="c1" />
							<colspec
								colnum="3"
								colname="c2" />
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>translation type</entry>
									<entry>java.lang.Integer</entry>
									<entry>Network specific ID which determines how global title analysis is performed.</entry>
								</row>
								<row>
									<entry>numbering plan</entry>
									<entry>enum</entry>
									<entry>Determines which numbering plan is used for global title. It can have one of following values:
										UNKNOWN, ISDN_TELEPHONY, DATA,
										TELEX, MERITIME_MOBILE, LAND_MOBILE, ISDN_MOBILE</entry>
								</row>
								<row>
									<entry>nature of address</entry>
									<entry>enum</entry>
									<entry>Determines type of address. It can have one of following values:
										SPARE, SUBSCRIBER, UNKNOWN, NATIONAL, INTERNATIONAL</entry>
								</row>
								<row>
									<entry>digits</entry>
									<entry>java.lang.String</entry>
									<entry>Simply digits of number, ie: +91 417688345892</entry>
								</row>
								<row>
									<entry>sub-system number</entry>
									<entry>java.lang.Integer</entry>
									<entry>local subsystem number, used to route between local services in SS7, ie. between HLR and VLR.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>translation</term>
				<listitem>
					<para>
						has the same structure as
						<literal>pattern</literal>
						. If
						<literal>pattern</literal>
						matches, destintion address is changed to
						<literal>translation</literal>
						.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>mtpinfo</term>
				<listitem>
					<para>
						<literal>mtpinfo</literal>
						indicates which link should be chosen when routing to remote location. In case routing is performed localy, its not present.
					</para>
					<table
						frame="all"
						pgwide="1">
						<title>mtpinfo content</title>
						<tgroup
							colsep="1"
							cols="3">
							<colspec
								colnum="1"
								colname="c0" />
							<colspec
								colnum="2"
								colname="c1" />
							<colspec
								colnum="3"
								colname="c2" />
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>name</entry>
									<entry>java.lang.String</entry>
									<entry></entry>
								</row>
								<row>
									<entry>adjacent point code</entry>
									<entry>java.lang.Integer</entry>
									<entry>point code of remote, mtp link.</entry>
								</row>
								<row>
									<entry>origin point code</entry>
									<entry>java.lang.Integer</entry>
									<entry>polint code of local, mtp link.</entry>
								</row>
								<row>
									<entry>signaling link selector</entry>
									<entry>java.lang.Integer</entry>
									<entry>number indicating TDM multiplexed link.</entry>
								</row>


							</tbody>
						</tgroup>
					</table>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>Example file entry looks as follows:</para>
		<!-- bad xml? -->
		<example>
			<title>sccp-routing.txt example entry</title>
			<programlisting
				language="XML"
				role="XML"><![CDATA[
0; #ISDN_MOBILE#NATIONAL#9023629581# ; #ISDN_MOBILE#INTERNATIONAL#79023629581# ;linkset#14083#14155#0
]]>
				</programlisting>
		</example>
		
		<variablelist>
			<varlistentry>
				<term>sequence</term>
				<listitem>
					<para> is set to 0, since its only rule in a file(or first).</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>pattern</term>
				<listitem>
					<para>matches natioan mobile number with following digits: <literal>9023629581</literal> </para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>translation</term>
				<listitem>
					<para>changes destination to international mobile with following digits: <literal>79023629581</literal>. Since no sub-system number is present, this rule requires <literal>mtpinfo</literal> 
					to indicate target.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>mtpinfo</term>
				<listitem>
					<para>indicates link through which message will be sent to next hop. Link:</para>
					<itemizedlist>
						<listitem>
							<para>Belongs to linkset with name equal to <literal>linkset</literal>. </para>
						</listitem>
						<listitem>
							<para>Adjacent point code is equal to <literal>14083</literal>. </para>
						</listitem>
						<listitem>
							<para>Origin point code is equal to <literal>14155</literal>. </para>
						</listitem>
						<listitem>
							<para>Signaling link selector is equal to <literal>0</literal>. Note that this value may be overriden by transport layer.  </para>
						</listitem>
						
					</itemizedlist>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	<section
		id="sccp_access_point">
		<title>Access Point</title>
		<para>
			<literal>SS7 Service</literal> provides user with access point to <literal>SCCP</literal> protocol/stack. 
			It can be used in following way:
		</para>
		<programlisting
			language="java"
			role="JAVA">
import org.jboss.jmx.adaptor.rmi.RMIAdaptor;
import java.util.*;
import javax.management.MBeanServerConnection;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.mobicents.protocols.ss7.*;
import org.mobicents.protocols.ss7.sccp.*;
import org.mobicents.protocols.ss7.indicator.*;

public class Test implements SccpListener
{

	private SccpProvider sccpProvider;
	private SccpAddress localAddress;
	
 	private MBeanServerConnection createMBeanServerConnection()
           throws NamingException
 	{	
 		//no arg is ok, if we run in JBoss
	 	InitialContext ctx = new InitialContext();
	 	
 	   
 	 	String adapterName = "jmx/invoker/RMIAdaptor";
 	   
 	 	Object obj = ctx.lookup(adapterName);
 	 	ctx.close();
 	   
 	 	if (!(obj instanceof RMIAdaptor))
 	 	{
 	 	 	throw new ClassCastException
 	 	 	("Object not of type: RMIAdaptorImpl, but: " +
 	 	 	(obj == null ? "not found" : obj.getClass().getName()));
 	 	}

 	 	return (MBeanServerConnection) obj;
  }

  public void start() throws Excetpion
  {
    //SS7Service is JMX bean, lets use it to get 
  	MBeanServerConnection con = createMBeanServerConnection();
  	ObjectName on = new ObjectName("org.mobicents.ss7:service=SS7Service");
  	
    String providerJndiName = con.invoke(on,"getJndiName",null,null);
    InitialContext ctx = new InitialContext();
	 	
    this.sccpProvider = (SccpProvider) ctx.lookup(providerJndiName);
    ctx.close();
    
    int translationType = 0;
    int subSystemNumber = 0; 
    GlobalTitle gt = GlobalTitle.getInstance(translationType,NumberingPlan.ISDN_MOBILE,NatureOfAddress.NATIONAL, "1234");
    localAddress = new SccpAddress(gt,0);
    
    sccProvider.registerSccpListener(localAddress,this);
  }

  public void stop()
  {
  	this.sccpProvider.deregisterSccpListener(localAddress);
  }

  public void onMessage(SccpMessage message)
  {
  		if (message.getType() == MessageType.UDT) {
              throw new IlleagalArgumentException("Dont like UDT");
            } else if (message.getType() == MessageType.XUDT) {
                XUnitData xudt = (XUnitData) message;
                localAddress = ((XUnitData)message).getCalledPartyAddress();
                remoteAddress = ((XUnitData)message).getCallingPartyAddress();
                
                //now decode content
                byte[] data = xudt.getData();
                //some data encoded in 
                CallRequest cr = new CallRequest(data);
                byte[] answerData;
                if(cr.getCallee().equals(this.localAddress))
                {
                	EstablihsCallAnswer eca = new EstablihsCallAnswer(cr);
                	answerData = eca.encode();
                }else
                {
                	TearDownCallAnswer tdca = new TearDownCallAnswer(cr);
                	answerData = tdca.encode();
                }
                

                HopCounter hc = this.provider.getParameterFactory().createHopCounter(5);
                XUnitData sccpAnswer = this.provider.getMessageFactory().createXUnitData(hc,xudt.getProtocolClass(),message.getCallingPartyAddress(),this.localAddress);
                this.provider.send(sccpAnswer);
            }
  		
  }

}
</programlisting>
	</section>
</chapter>